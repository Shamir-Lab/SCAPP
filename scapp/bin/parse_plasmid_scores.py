#!/usr/bin/env python

# parse contig scores from PlasFlow output files, write to file
# to be used by Recycler
# usage: python -i <input file> -o <output file>

import re, argparse, os, math

def parse_user_input():
    parser = argparse.ArgumentParser(
        description=
        'parse_plasmid_scores parses the output from PlasClass or PlasFlow and converts to Recycler input format'
        )
    parser.add_argument('-i','--infile',
     help='input file - generated by PlasClass or PlasFlow',
     required=True, type=str
     )
    parser.add_argument('-o','--outfile',
     help='output file name for contig plasmid scores',
     required=False, type=str
     )

    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-pc', '--plasclass' ,action='store_true', default=True)
    group.add_argument('-pf', '--plasflow', action='store_true', default=False)

    return parser.parse_args()

def parsePlasClass(filename):
    """ Parse the file into lists of edge names, lengths, and PlasClass scores

    """

    with open(filename) as f:
        names = []
        lengths = []
        scores = []
        name = ''
        for line in f:
            splt = line.strip().split('\t')
            edge_name = splt[0]
            # convert name from fastg header format to single edge name
            name = re.split(':|;',edge_name)[0]
            names.append(name)
            length = int(name.split('_')[3])
            lengths.append(length)
            score = float(splt[1])
            scores.append(score)
    return names, lengths, scores


def parsePlasFlow(filename):
    """ Parse the file into lists of edge names, lengths, and PlasFlow scores
    """

    with open(filename) as f:
        names = []
        lengths = []
        scores = []
        # read header
        plasmid_inds = []
        is_header = True
        for line in f:
            if is_header:
                is_header = False
                for i,v in enumerate(line.split('\t')):
                    if v == "contig_name":
                        name_ind = i
                    elif v == "contig_length":
                        len_ind = i
                    elif "plasmid" in v:
                        plasmid_inds.append(i)
                continue
            # parse lines and store names, lengths, scores
            fields = line.split('\t')
            # convert name from fastg header format to single edge name
            name = re.split(':|;',fields[name_ind])[0]
            names.append(name)
            lengths.append(int(fields[len_ind]))
            score = sum([float(fields[x]) for x in plasmid_inds])

    return names, lengths, scores

def transformByLength(lengths, scores):
    """ pull scores of short contigs towards 0.5
        For score x, length l:
        (x-0.5)*1/(1+e^(-0.001(l-2000))) + 0.5

    """
    transformed = []
    for i,v in enumerate(scores):
        l = lengths[i]
        weight = 1.0/(1+math.exp(-0.001*float(l-2000)))
        t = (v-0.5)*weight + 0.5
        transformed.append(t)
    return transformed

def writeOutput(outfile,edges,scores):
    with open(outfile,'w') as o:
        for e,s in zip(edges,scores):
            o.write(e+'\t'+str(s)+'\n')

def transformPlasClass(infile,outfile):
    edges, lengths, scores = parsePlasClass(infile)
    scores = transformByLength(lengths, scores)
    writeOutput(outfile,edges,scores)

def transformPlasFlow(infile,outfile):
    edges, lengths, scores = parsePlasFlow(infile)
    scores = transformByLength(lengths, scores)
    writeOutput(outfile,edges,scores)

if __name__=='__main__':
    args = parse_user_input()
    infile = args.infile
    outfile = args.outfile
    plasflow = args.plasflow
    plasclass = args.plasclass

    if plasclass:
        transformPlasClass(infile, outfile)
    elif plasflow:
        transformPlasFlow(infile, outfile)
